###Engineering Summary â€” Sprint 1 Day 1
Outcome Status: Completed
Delivered
Signup flow stÃ¸tter nÃ¥ demografiske felter:
gender
country
city
age
Feltene er obligatoriske i frontend.
Backend /api/auth/signup aksepterer og lagrer feltene.
Data persisteres i state/users/<uid>/auth.json.
Full bakoverkompatibilitet for eksisterende brukere.
Carry-over
Ingen.
Key Technical Changes
Frontend: utvidet signup-form state, validering og payload.
API-client: utvidet signup payload-typer.
Backend: Signup schema + persistence utvidet.
Ingen endringer i sessions, SSOT-strukturer eller auth-indexing.
New Constraints / Discoveries
.fly/config.yml korrupsjon kan blokkere deploy (ikke kode-relatert).
Manglende .dockerignore gir ekstrem build-context.
Systems Touched
Signup frontend
Auth API signup-endepunkt
auth.json persistence
Systems Untouched
Sessions / rides / SSOT
Strava
Analyzer / Rust
Meta-systemer
###Profilversjonering

###ğŸŸ¥ ENGINEER WORK LOG â€” Sprint Week 1, Day 2 (Condensed)
Date: Feb 12, 2026
Focus: Dashboard Profile (Read-Only)

Objective
Enable users to view profile data in Dashboard (editing comes Day 3).

Done
Added Profile anchor in Dashboard header
Implemented compact Profile Peek Card under Goals
Fetches from GET /api/profile/get
Handles loading, error, and defensive empty state
Displays key rider/bike metrics + profile version
FTP shows â€œNot setâ€ when null
Desktop: hover reveal â€¢ Mobile: tap reveal
Styling aligned with Dashboard glass-card system
Architecture

/profile remains edit/settings page
Dashboard card is strictly read-only
profile.json remains SSOT
No backend or data model changes
Clean separation: Settings (write) â†’ API â†’ Dashboard (read)

Testing
Verified render for existing user
Null handling confirmed
No console errors
Anchor scroll works
Responsive behavior OK
Defensive fallback present (onboarding normally guarantees profile)

Files
frontend/src/routes/DashboardPage.tsx
frontend/src/components/Profile/ProfilePeekCard.tsx
frontend/src/api/profile.ts
Backend: unchanged


###ğŸ›  Engineer Worklog â€“ Day 3 (Condensed)
Sprint: Profile Isolation
Focus: Eliminate implicit re-analyze / enforce deterministic history

ğŸ¯ Objective
Prevent historical sessions from being recomputed when profile values change. Ensure deterministic SSOT behavior.

ğŸ” Root Cause
Session view implicitly triggered:
POST /api/sessions/{sid}/analyze
Without explicit flags, backend entered compute-path, causing historical rides to reflect updated profile values.
Backend result files were not corrupted, but view-load triggered recompute logic.

âœ… Solution Implemented
Backend
Added use_cached=1 support in /api/sessions/{sid}/analyze
If use_cached=1 and no force_recompute, return cached result only
No compute, no persistence

Frontend
fetchSession() now defaults to use_cached=1
Analyze button explicitly sets force_recompute=1

ğŸ§  Resulting Behavior
Action	Behavior
Open historical session	Cached result only
Change profile	No impact on old sessions
Click Analyze	Explicit recompute
New session without cache	Compute once
System is now deterministic and recompute is fully controlled.

ğŸ Status
Implicit re-analyze eliminated.
Historical sessions are frozen.
Recompute is explicit only.
Core sprint blocker resolved.
